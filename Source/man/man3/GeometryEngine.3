.TH "GeometryEngine" 3 "Mercredi 12 Janvier 2022" "Moteur De Jeu" \" -*- nroff -*-
.ad l
.nh
.SH NAME
GeometryEngine \- la classe \fBGeometryEngine\fP effectue toute les actions en rapport aux maillage  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <geometryengine\&.h>\fP
.PP
Est dérivée de QOpenGLFunctions_4_1_Core\&.
.PP
Dérivée par \fBGeometryMeshEngine\fP\&.
.SS "Fonctions membres publiques"

.in +1c
.ti -1c
.RI "\fBGeometryEngine\fP ()"
.br
.RI "[0] "
.ti -1c
.RI "virtual void \fBdrawCubeGeometry\fP (QOpenGLShaderProgram *program)"
.br
.RI "dessine le mesh bind "
.ti -1c
.RI "virtual void \fBinitMesh\fP (std::string filename, bool collisionActivated=true, bool centre=false, bool inverse=false)"
.br
.RI "initMesh methode virtuel, voir \fBGeometryMeshEngine::initMesh()\fP "
.ti -1c
.RI "virtual void \fBinitMeshObj\fP (std::string filename, bool collisionActivated=true, bool centre=false, bool inverse=false)"
.br
.RI "initMeshObj methode virtuel, voir \fBGeometryMeshEngine::initMeshObj()\fP "
.ti -1c
.RI "virtual void \fBbindMesh\fP (std::vector< std::vector< unsigned int > > faces, bool centre=false, bool inverse=false)"
.br
.RI "bindMesh methode virtuel, voir \fBGeometryMeshEngine::bindMesh()\fP "
.ti -1c
.RI "virtual void \fBinitLifeBar\fP ()"
.br
.RI "virtual, voir BillboardObject::initLifeBar() "
.ti -1c
.RI "virtual bool \fBupdateLifeBar\fP (double deltaTime)"
.br
.RI "virtual, voir BillboardObject::updateLifeBar() "
.ti -1c
.RI "virtual QVector3D \fBsetNormalToCentreCircle\fP (QVector3D vec, QVector3D centre, bool inverse)"
.br
.RI "virtual, voir \fBGeometryMeshEngine::setNormalToCentreCircle\fP "
.ti -1c
.RI "void \fBinitCubeGeometry\fP ()"
.br
.RI "créer un cube "
.ti -1c
.RI "void \fBinitPlanegeometry\fP (float Xmin=\-1, float Ymin=\-1, float Xmax=1, float Ymax=1, float centreX=0, float centreY=0)"
.br
.RI "initialise la conseption d'un plan, appel à \fBsubdivisePlan()\fP et bind les buffers "
.ti -1c
.RI "void \fBinitCurvedPlanegeometry\fP (float Xmin, float Ymin, float Xmax, float Ymax, bool collisionActivated)"
.br
.RI "initialise la conseption d'un plan incurvé, appel à \fBsubdiviseCurvedPlan()\fP et bind les buffers "
.ti -1c
.RI "void \fBsetPrecisionTexture\fP (float val)"
.br
.RI "change la precision de la texture "
.ti -1c
.RI "QVector3D \fBfindCoordmesh\fP (\fBGeometryEngine\fP *geo, QMatrix4x4 objM, QMatrix4x4 ourM, bool &collision, QVector3D &mesh)"
.br
.RI "findCoordmesh gère la collision entre objet et terrain\&. "
.ti -1c
.RI "QVector3D \fBgetNormal\fP ()"
.br
.ti -1c
.RI "QVector3D \fBgetNormal\fP (QVector3D \fBvertex\fP)"
.br
.ti -1c
.RI "QVector3D \fBrecallageCollision\fP (\fBGeometryEngine\fP *geoB, int instance=\-1)"
.br
.RI "recallageCollision "
.ti -1c
.RI "void \fBresetBB\fP ()"
.br
.RI "resetBB réinitialise la AABB "
.ti -1c
.RI "bool \fBifNoeudVide\fP ()"
.br
.ti -1c
.RI "void \fBremplaceBB\fP (\fBGeometryEngine\fP *geo)"
.br
.RI "remplaceBB remplace la AABB "
.ti -1c
.RI "void \fBremplaceBB\fP (QVector3D m, QVector3D M)"
.br
.RI "remplaceBB remplace la AABB "
.ti -1c
.RI "void \fBupdateBB\fP (QMatrix4x4 m, QMatrix4x4 lastM=QMatrix4x4(), QMatrix4x4 courante=QMatrix4x4())"
.br
.RI "updateBB "
.ti -1c
.RI "void \fBajustBB\fP (\fBGeometryEngine\fP *geo)"
.br
.RI "ajustBB combine deux AABB "
.ti -1c
.RI "void \fBajustBB\fP (QVector3D min, QVector3D max)"
.br
.RI "ajustBB combine deux AABB "
.ti -1c
.RI "bool \fBintersect\fP (\fBGeometryEngine\fP *geo)"
.br
.RI "intersect verifie si une intersection a lieu entre l'objet et la AABB du noeud du gameobject "
.ti -1c
.RI "bool \fBinternintersect\fP (\fBGeometryEngine\fP *geo, int &numInstence, QMatrix4x4 AllTransform=QMatrix4x4())"
.br
.RI "internintersect verifie si une intersection a lieu entre l'objet et la AABB du mesh du gameobject "
.ti -1c
.RI "bool \fBinternintersectInstenced\fP (\fBGeometryEngine\fP *geo, int &numInstence, QMatrix4x4 AllTransform=QMatrix4x4())"
.br
.RI "internintersectInstenced verifie si une intersection a lieu entre l'objet et la AABB d'une instance du mesh "
.ti -1c
.RI "QVector3D \fBgestionCollision\fP (\fBGeometryEngine\fP *geo, QVector3D vec)"
.br
.RI "gestionCollision une fois la collision detecter, gère la collision AABB vs AABB avec la reflexion "
.ti -1c
.RI "QVector3D \fBgestionCollision\fP (QVector3D vec, QVector3D mesh)"
.br
.RI "gestionCollision une fois la collision detecter, gère la collision AABB vs Terrain avec la reflexion "
.ti -1c
.RI "QVector3D \fBgestionCollision\fP (\fBGeometryEngine\fP *geo, QVector3D vec, int numInstenced)"
.br
.RI "gestionCollision une fois la collision detecter, gère la collision AABB vs AABB instenced avec la reflexion "
.ti -1c
.RI "QVector3D \fBmapCoordChanged\fP (QVector3D vec, QMatrix4x4 objM, QMatrix4x4 ourM)"
.br
.RI "mapCoordChanged gère les changement de coordonnée du joueur afin que la carte reste centrée sur le joueur "
.ti -1c
.RI "void \fBaddInstancedGrass\fP (float ratioArbre=0\&.42, QVector3D min=QVector3D(\-13,\-13, 0), QVector3D max=QVector3D(13, 13, 0))"
.br
.RI "addInstancedGrass ajoute un nombre d'instance d'arbre "
.ti -1c
.RI "void \fBcoordLastCollisionUpdateForMeshsCollision\fP (\fBGeometryEngine\fP *geo, QMatrix4x4 objM)"
.br
.RI "coordLastCollisionUpdateForMeshsCollision met à jour les coordonnée du dernier impacte lors d'une collision AABB vs AABB "
.in -1c
.SS "Fonctions membres publiques statiques"

.in +1c
.ti -1c
.RI "static QVector3D \fBcalcBBMin\fP (QVector3D const &last, QVector3D const &min)"
.br
.RI "calcBBMin renvoie le vecteur avec les coordonnée les plus petite entre last et min "
.ti -1c
.RI "static QVector3D \fBcalcBBMax\fP (QVector3D const &last, QVector3D const &max)"
.br
.RI "calcBBMin renvoie le vecteur avec les coordonnée les plus grande entre last et max "
.in -1c
.SS "Attributs publics"

.in +1c
.ti -1c
.RI "bool \fBwithTextureCoord\fP = false"
.br
.ti -1c
.RI "QVector< \fBMinMax\fP > \fBinternbbInstenced\fP"
.br
.ti -1c
.RI "QVector3D \fBcoordLastCollision\fP = QVector3D(999,999,999)"
.br
.ti -1c
.RI "QVector2D \fBlastCentre\fP = QVector2D(0,0)"
.br
.ti -1c
.RI "QVector3D \fBBBMin\fP = QVector3D(0,0,0)"
.br
.RI "BBMin: minimum de la AABB du noeud (englobe les AABB des enfants) dans l'espace monde\&. "
.ti -1c
.RI "QVector3D \fBBBMax\fP = QVector3D(0,0,0)"
.br
.RI "BBMax: maximum de la AABB du noeud (englobe les AABB des enfants) dans l'espace monde\&. "
.ti -1c
.RI "QVector3D \fBinternBBMin\fP = QVector3D(0,0,0)"
.br
.RI "internBBMin: minimum de la AABB du mesh dans l'espace monde "
.ti -1c
.RI "QVector3D \fBinternBBMax\fP = QVector3D(0,0,0)"
.br
.RI "internBBMax: maximum de la AABB du mesh dans l'espace monde "
.ti -1c
.RI "bool \fBwithNormal\fP = false"
.br
.ti -1c
.RI "bool \fBheightMap\fP = false"
.br
.ti -1c
.RI "bool \fBnoCollision\fP = false"
.br
.ti -1c
.RI "float \fBprecisionTexture\fP =1"
.br
.ti -1c
.RI "QOpenGLBuffer \fBarrayBuf\fP"
.br
.ti -1c
.RI "QOpenGLBuffer \fBindexBuf\fP"
.br
.ti -1c
.RI "QVector< QMatrix4x4 > \fBmodelMatrices\fP"
.br
.RI "modelMatrices contient les matrice de transformation des instance si elles existent "
.ti -1c
.RI "int \fBtriangle_strip\fP = 0"
.br
.in -1c
.SS "Fonctions membres protégées"

.in +1c
.ti -1c
.RI "void \fBsubdivisePlan\fP (int x, int y, \fBVertexData\fP vertices[], float Xmin, float Ymin, float Xmax, float Ymax, float centreX=0, float centreY=0)"
.br
.RI "Subdivise le plan de precision x et y,\&. "
.ti -1c
.RI "void \fBsubdiviseCurvedPlan\fP (int x, int y, \fBVertexData\fP vertices[], float Xmin=\-1, float Ymin=\-1, float Xmax=1, float Ymax=1)"
.br
.RI "Subdivise le plan incurvé de precision x et y,\&. "
.ti -1c
.RI "void \fBTriangleStripForPlan\fP (int x, int y, GLushort indices[])"
.br
.RI "TriangleStripForPlan ordonne les indices en triangleStrip\&. "
.ti -1c
.RI "void \fBupdatePlanegeometry\fP (float Xmin, float Ymin, float Xmax, float Ymax, float centreX=0, float centreY=0)"
.br
.RI "updatePlanegeometry met a jour le plan du terrain "
.ti -1c
.RI "unsigned int \fBconvertStripToTriangle\fP (GLushort indicesIn[], GLushort indicesOut[], int size)"
.br
.RI "convertStripToTriangle "
.ti -1c
.RI "std::vector< QVector3D > \fBgetVertex\fP ()"
.br
.ti -1c
.RI "void \fBinitBB\fP (std::vector< QVector3D > \fBvertex\fP)"
.br
.RI "initBB initialise Min et Max en fonction de vertex "
.ti -1c
.RI "void \fBinitBB\fP (\fBVertexData\fP vertices[], int i)"
.br
.RI "initBB initialise Min et Max en fonction de vertices "
.ti -1c
.RI "void \fBsetBBMin\fP (QVector3D v)"
.br
.ti -1c
.RI "void \fBsetBBMax\fP (QVector3D v)"
.br
.in -1c
.SS "Attributs protégés"

.in +1c
.ti -1c
.RI "std::vector< QVector3D > \fBvertex\fP"
.br
.RI "vertex contient le maillage "
.ti -1c
.RI "QVector3D \fBMin\fP = QVector3D(0,0,0)"
.br
.RI "Min min de l'AABB du mesh\&. "
.ti -1c
.RI "QVector3D \fBMax\fP = QVector3D(0,0,0)"
.br
.RI "Max max de l'AABB du mesh\&. "
.ti -1c
.RI "int \fBprecisionX\fP = 101"
.br
.RI "precisionX presision du maillage "
.ti -1c
.RI "int \fBprecisionY\fP = 101"
.br
.RI "precisionY presision du maillage "
.in -1c
.SH "Description détaillée"
.PP 
la classe \fBGeometryEngine\fP effectue toute les actions en rapport aux maillage 
.SH "Documentation des fonctions membres"
.PP 
.SS "void GeometryEngine::addInstancedGrass (float ratioArbre = \fC0\&.42\fP, QVector3D min = \fCQVector3D(\-13,\-13,0)\fP, QVector3D max = \fCQVector3D(13,13,0)\fP)"

.PP
addInstancedGrass ajoute un nombre d'instance d'arbre ajoute un nombre d'instances
.PP
\fBParamètres\fP
.RS 4
\fIratioArbre\fP devenu inutile 
.br
\fImin\fP 
.br
\fImax\fP 
.br
\fIratioArbre\fP obsolete 
.br
\fImin\fP intervalle de la carte 
.br
\fImax\fP intervalle de la carte 
.RE
.PP

.SS "void GeometryEngine::ajustBB (\fBGeometryEngine\fP * geo)"

.PP
ajustBB combine deux AABB 
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.RE
.PP

.SS "void GeometryEngine::ajustBB (QVector3D min, QVector3D max)"

.PP
ajustBB combine deux AABB 
.PP
\fBParamètres\fP
.RS 4
\fImin\fP 
.br
\fImax\fP 
.RE
.PP

.SS "virtual void GeometryEngine::bindMesh (std::vector< std::vector< unsigned int > > faces, bool centre = \fCfalse\fP, bool inverse = \fCfalse\fP)\fC [inline]\fP, \fC [virtual]\fP"

.PP
bindMesh methode virtuel, voir \fBGeometryMeshEngine::bindMesh()\fP 
.PP
\fBParamètres\fP
.RS 4
\fIfaces\fP tableau des face de l'objet 
.br
\fIcentre\fP pour changer la direction des normals 
.br
\fIinverse\fP inverse la direction des normals 
.RE
.PP

.SS "QVector3D GeometryEngine::calcBBMax (QVector3D const & last, QVector3D const & max)\fC [static]\fP"

.PP
calcBBMin renvoie le vecteur avec les coordonnée les plus grande entre last et max 
.PP
\fBParamètres\fP
.RS 4
\fIlast\fP 
.br
\fImin\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "QVector3D GeometryEngine::calcBBMin (QVector3D const & last, QVector3D const & min)\fC [static]\fP"

.PP
calcBBMin renvoie le vecteur avec les coordonnée les plus petite entre last et min 
.PP
\fBParamètres\fP
.RS 4
\fIlast\fP 
.br
\fImin\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "unsigned int GeometryEngine::convertStripToTriangle (GLushort indicesIn[], GLushort indicesOut[], int size)\fC [protected]\fP"

.PP
convertStripToTriangle 
.PP
\fBParamètres\fP
.RS 4
\fIindicesIn\fP 
.br
\fIindicesOut\fP 
.br
\fIsize\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "void GeometryEngine::coordLastCollisionUpdateForMeshsCollision (\fBGeometryEngine\fP * geo, QMatrix4x4 objM)"

.PP
coordLastCollisionUpdateForMeshsCollision met à jour les coordonnée du dernier impacte lors d'une collision AABB vs AABB 
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.br
\fIobjM\fP 
.RE
.PP

.SS "void GeometryEngine::drawCubeGeometry (QOpenGLShaderProgram * program)\fC [virtual]\fP"

.PP
dessine le mesh bind [2]
.PP
\fBParamètres\fP
.RS 4
\fIprogram\fP le shader 
.RE
.PP

.PP
Réimplémentée dans \fBGeometryMeshEngine\fP\&.
.SS "QVector3D GeometryEngine::findCoordmesh (\fBGeometryEngine\fP * geo, QMatrix4x4 objM, QMatrix4x4 ourM, bool & collision, QVector3D & mesh)"

.PP
findCoordmesh gère la collision entre objet et terrain\&. 
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP le geometryEngine de l'objet 
.br
\fIobjM\fP matrice de transformation de geometryEngine 
.br
\fIourM\fP matrice de transformation du terrain 
.br
\fIcollision[out]\fP boolean si collision ou non 
.br
\fImesh[out]\fP coord du mesh ou l'impact a lieu 
.RE
.PP
\fBRenvoie\fP
.RS 4
retourne le vecteur reflechit 
.RE
.PP
TODO
.SS "QVector3D GeometryEngine::gestionCollision (\fBGeometryEngine\fP * geoB, QVector3D vec)"

.PP
gestionCollision une fois la collision detecter, gère la collision AABB vs AABB avec la reflexion gestion de la collision avec gameObject
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.br
\fIvec\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP
\fBParamètres\fP
.RS 4
\fIgeoB\fP 
.br
\fIvec\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "QVector3D GeometryEngine::gestionCollision (\fBGeometryEngine\fP * geoB, QVector3D vec, int numInstenced)"

.PP
gestionCollision une fois la collision detecter, gère la collision AABB vs AABB instenced avec la reflexion gestion de la collision avec le terrain avec un gameobject contenant un nombre n d'instance
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.br
\fIvec\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP
\fBParamètres\fP
.RS 4
\fIgeoB\fP 
.br
\fIvec\fP 
.br
\fInumInstenced\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "QVector3D GeometryEngine::gestionCollision (QVector3D vec, QVector3D point)"

.PP
gestionCollision une fois la collision detecter, gère la collision AABB vs Terrain avec la reflexion gestion de la collision avec le terrain
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.br
\fIvec\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP
\fBParamètres\fP
.RS 4
\fIvec\fP 
.br
\fIpoint\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "void GeometryEngine::initBB (std::vector< QVector3D > vertex)\fC [protected]\fP"

.PP
initBB initialise Min et Max en fonction de vertex 
.PP
\fBParamètres\fP
.RS 4
\fIvertex\fP 
.RE
.PP

.SS "void GeometryEngine::initBB (\fBVertexData\fP vertices[], int i)\fC [protected]\fP"

.PP
initBB initialise Min et Max en fonction de vertices 
.PP
\fBParamètres\fP
.RS 4
\fIvertex\fP 
.RE
.PP

.SS "void GeometryEngine::initCubeGeometry ()"

.PP
créer un cube [1]
.PP
[1]
.SS "void GeometryEngine::initCurvedPlanegeometry (float Xmin, float Ymin, float Xmax, float Ymax, bool collisionActivated)"

.PP
initialise la conseption d'un plan incurvé, appel à \fBsubdiviseCurvedPlan()\fP et bind les buffers 
.PP
\fBParamètres\fP
.RS 4
\fIXmin\fP 
.br
\fIYmin\fP 
.br
\fIXmax\fP 
.br
\fIYmax\fP 
.br
\fIcollisionActivated\fP boolean si collision 
.RE
.PP
[1]
.PP
[1]
.SS "virtual void GeometryEngine::initLifeBar ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
virtual, voir BillboardObject::initLifeBar() 
.PP
Réimplémentée dans \fBgeometryUI\fP\&.
.SS "virtual void GeometryEngine::initMesh (std::string filename, bool collisionActivated = \fCtrue\fP, bool centre = \fCfalse\fP, bool inverse = \fCfalse\fP)\fC [inline]\fP, \fC [virtual]\fP"

.PP
initMesh methode virtuel, voir \fBGeometryMeshEngine::initMesh()\fP 
.PP
\fBParamètres\fP
.RS 4
\fIfilename\fP 
.br
\fIcollisionActivated\fP vrai si collision activé 
.br
\fIcentre\fP pour changer la direction des normals 
.br
\fIinverse\fP inverse la direction des normals 
.RE
.PP

.PP
Réimplémentée dans \fBGeometryMeshEngine\fP\&.
.SS "virtual void GeometryEngine::initMeshObj (std::string filename, bool collisionActivated = \fCtrue\fP, bool centre = \fCfalse\fP, bool inverse = \fCfalse\fP)\fC [inline]\fP, \fC [virtual]\fP"

.PP
initMeshObj methode virtuel, voir \fBGeometryMeshEngine::initMeshObj()\fP 
.PP
\fBParamètres\fP
.RS 4
\fIfilename\fP 
.br
\fIcollisionActivated\fP vrai si collision activé 
.br
\fIcentre\fP pour changer la direction des normals 
.br
\fIinverse\fP inverse la direction des normals 
.RE
.PP

.PP
Réimplémentée dans \fBGeometryMeshEngine\fP\&.
.SS "void GeometryEngine::initPlanegeometry (float Xmin = \fC\-1\fP, float Ymin = \fC\-1\fP, float Xmax = \fC1\fP, float Ymax = \fC1\fP, float centreX = \fC0\fP, float centreY = \fC0\fP)"

.PP
initialise la conseption d'un plan, appel à \fBsubdivisePlan()\fP et bind les buffers 
.PP
\fBParamètres\fP
.RS 4
\fIXmin\fP 
.br
\fIYmin\fP 
.br
\fIXmax\fP 
.br
\fIYmax\fP 
.br
\fIcentreX\fP centre du terrain axe X 
.br
\fIcentreY\fP centre du terrain axe Y 
.RE
.PP
[1]
.PP
[1]
.SS "bool GeometryEngine::internintersect (\fBGeometryEngine\fP * geo, int & numInstence, QMatrix4x4 AllTransform = \fCQMatrix4x4()\fP)"

.PP
internintersect verifie si une intersection a lieu entre l'objet et la AABB du mesh du gameobject 
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.br
\fInumInstence\fP lorsque la collision a lieu avec un objet instencié 
.br
\fIAllTransform\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "bool GeometryEngine::internintersectInstenced (\fBGeometryEngine\fP * geo, int & numInstence, QMatrix4x4 AllTransform = \fCQMatrix4x4()\fP)"

.PP
internintersectInstenced verifie si une intersection a lieu entre l'objet et la AABB d'une instance du mesh 
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.br
\fInumInstence\fP numero de l'instance 
.br
\fIAllTransform\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "bool GeometryEngine::intersect (\fBGeometryEngine\fP * geo)"

.PP
intersect verifie si une intersection a lieu entre l'objet et la AABB du noeud du gameobject 
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "QVector3D GeometryEngine::mapCoordChanged (QVector3D vec, QMatrix4x4 objM, QMatrix4x4 ourM)"

.PP
mapCoordChanged gère les changement de coordonnée du joueur afin que la carte reste centrée sur le joueur 
.PP
\fBParamètres\fP
.RS 4
\fIvec\fP 
.br
\fIobjM\fP 
.br
\fIourM\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "QVector3D GeometryEngine::recallageCollision (\fBGeometryEngine\fP * geoB, int instance = \fC\-1\fP)"

.PP
recallageCollision 
.PP
\fBParamètres\fP
.RS 4
\fIgeoB\fP 
.br
\fIinstance\fP 
.RE
.PP
\fBRenvoie\fP
.RS 4
.RE
.PP

.SS "void GeometryEngine::remplaceBB (\fBGeometryEngine\fP * geo)"

.PP
remplaceBB remplace la AABB 
.PP
\fBParamètres\fP
.RS 4
\fIgeo\fP 
.RE
.PP

.SS "void GeometryEngine::remplaceBB (QVector3D m, QVector3D M)"

.PP
remplaceBB remplace la AABB 
.PP
\fBParamètres\fP
.RS 4
\fIm\fP 
.br
\fIM\fP 
.RE
.PP

.SS "virtual QVector3D GeometryEngine::setNormalToCentreCircle (QVector3D vec, QVector3D centre, bool inverse)\fC [inline]\fP, \fC [virtual]\fP"

.PP
virtual, voir \fBGeometryMeshEngine::setNormalToCentreCircle\fP 
.PP
Réimplémentée dans \fBGeometryMeshEngine\fP\&.
.SS "void GeometryEngine::setPrecisionTexture (float val)"

.PP
change la precision de la texture [0]
.PP
\fBParamètres\fP
.RS 4
\fIval\fP 
.RE
.PP

.SS "void GeometryEngine::subdiviseCurvedPlan (int x, int y, \fBVertexData\fP vertices[], float Xmin = \fC\-1\fP, float Ymin = \fC\-1\fP, float Xmax = \fC1\fP, float Ymax = \fC1\fP)\fC [protected]\fP"

.PP
Subdivise le plan incurvé de precision x et y,\&. 
.PP
\fBParamètres\fP
.RS 4
\fIx\fP precision 
.br
\fIy\fP precision 
.br
\fIvertices\fP 
.br
\fIXmin\fP intervalle 
.br
\fIYmin\fP intervalle 
.br
\fIXmax\fP intervalle 
.br
\fIYmax\fP intervalle 
.RE
.PP

.SS "void GeometryEngine::subdivisePlan (int x, int y, \fBVertexData\fP vertices[], float Xmin = \fC\-1\fP, float Ymin = \fC\-1\fP, float Xmax = \fC1\fP, float Ymax = \fC1\fP, float centreX = \fC0\fP, float centreY = \fC0\fP)\fC [protected]\fP"

.PP
Subdivise le plan de precision x et y,\&. 
.PP
\fBParamètres\fP
.RS 4
\fIx\fP precision 
.br
\fIy\fP precision 
.br
\fIvertices\fP 
.br
\fIXmin\fP intervalle 
.br
\fIYmin\fP intervalle 
.br
\fIXmax\fP intervalle 
.br
\fIYmax\fP intervalle 
.br
\fIcentreX\fP centre du terrain axe X 
.br
\fIcentreY\fP centre du terrain axe Y 
.RE
.PP

.SS "void GeometryEngine::TriangleStripForPlan (int x, int y, GLushort indices[])\fC [protected]\fP"

.PP
TriangleStripForPlan ordonne les indices en triangleStrip\&. 
.PP
\fBParamètres\fP
.RS 4
\fIx\fP 
.br
\fIy\fP 
.br
\fIindices\fP 
.RE
.PP

.SS "void GeometryEngine::updateBB (QMatrix4x4 m, QMatrix4x4 lastM = \fCQMatrix4x4()\fP, QMatrix4x4 courante = \fCQMatrix4x4()\fP)"

.PP
updateBB 
.PP
\fBParamètres\fP
.RS 4
\fIm\fP 
.br
\fIlastM\fP 
.br
\fIcourante\fP 
.RE
.PP
updateBB met a jour la AABB avec la matrice de transformation 
.PP
\fBParamètres\fP
.RS 4
\fIm\fP matrice de base 
.br
\fIlastM\fP matrice utilisé dans le cas d'objet instancié 
.br
\fIcourante\fP matrice utilisé dans le cas d'objet instancié 
.RE
.PP

.SS "virtual bool GeometryEngine::updateLifeBar (double deltaTime)\fC [inline]\fP, \fC [virtual]\fP"

.PP
virtual, voir BillboardObject::updateLifeBar() 
.PP
Réimplémentée dans \fBgeometryUI\fP\&.
.SS "void GeometryEngine::updatePlanegeometry (float Xmin, float Ymin, float Xmax, float Ymax, float centreX = \fC0\fP, float centreY = \fC0\fP)\fC [protected]\fP"

.PP
updatePlanegeometry met a jour le plan du terrain 
.PP
\fBParamètres\fP
.RS 4
\fIXmin\fP intervalle 
.br
\fIYmin\fP intervalle 
.br
\fIXmax\fP intervalle 
.br
\fIYmax\fP intervalle 
.br
\fIcentreX\fP centre du terrain axe X 
.br
\fIcentreY\fP centre du terrain axe Y 
.RE
.PP


.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour Moteur De Jeu à partir du code source\&.
